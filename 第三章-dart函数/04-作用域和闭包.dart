//最大作用域为全局Global
//闭包的实现是通过函数嵌套函数，内部函数引用外部函数的变量，这样就形成了闭包。,简单的说就是函数内部可以访问函数外部的变量。实现方式与JavaScript类似。
//什么时候使用闭包？当需要重用变量,但是又不想将变量暴露在全局作用域时，可以使用闭包。
//闭包实现原理:函数嵌套函数，内部函数引用外部函数的变量，导致外层函数的作用域对象无法被释放,从而形成了闭包。
//闭包的作用:1.可以访问外部函数的变量 2.可以保留外部函数的作用域对象
//闭包的缺点:1.内存泄漏 2.性能问题
//闭包的应用场景:1.事件处理函数 2.回调函数 3.定时器函数 4.模块化编程 5.函数柯里化 6.函数防抖 7.函数节流
//闭包的单词:closure

//声明全局变量
var globalNum = 100;

void main() {
  printInfo() {
    //局部变量
    var localNum = 10;
    localNum++; //表示局部变量自增
    print("局部变量:$localNum");
    print("全局变量:$globalNum"); //可以在函数内部访问全局变量,内层访问外层可以,反过来不行
  } //printInfo函数表示局部作用域

  printInfo(); //调用局部作用域函数,使之运行
  //print(localNum); //局部变量无法访问,不能在全局作用域中访问局部变量

  printInfo(); //再次调用局部作用域函数,使之运行
  printInfo(); //调用第三次,可见没有闭包情况下,每次调用都会重新初始化局部变量,所以输出的局部变量都是9

//闭包的实现
  parent() {
    var money = 100; //每次调用函数,金钱都是100,外层函数没有被释放,每次调用都会被记录下来
    return () {
      money -= 10; //每次调用函数,金钱减10,内层函数的内存会被释放
      print(money);
    }; //定义金钱为100,返回一个函数,每次调用函数,金钱减10,然后输出
  }

  //print(money); //报错,因为money是parent函数的局部变量,在全局作用域无法访问,从而避免了污染,实现保护

  var p = parent();
  p(); //90
  p(); //80
  p(); //70,每次调用都会减10,连续调用3次,这是闭包的执行的结果
}

//end
